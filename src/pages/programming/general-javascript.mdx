---
title: 'General Javascript'
---

import Todo from '../../components/Todo';

# General JavaScript

- ECMAScript [compatibility table](https://kangax.github.io/compat-table/es6/)
- [2ality](http://2ality.com/)
- Learn about relative performance of different object and array operations.
- Learn how to find and fix bottlenecks in code and articulate tradeoffs between
  different options
- Learn about the topic of data structures and master the most popular: arrays,
  maps, sets, DOM trees.
- Understand Big O notation
- Understand tree traversal
- Practice explaining your code and your choices
- Study raw DOM APIs
- Take a utility library like lodash and implement some methods and compare your
  solutions in terms of performance, understand what edge cases you need to
  handle

## Functional JavaScript

- [State Monad in
  JavaScript](https://egghead.io/courses/state-monad-in-javascript)
- [Function composition with
  lodash](https://hackernoon.com/function-composition-with-lodash-d30eb50153d1)
- [Professor Frisby Introduces Composable Functional
  JavaScript](https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript)
- [Professor Frisby's Mostly Adequate Guide To Functional
  Programming](https://github.com/MostlyAdequate/mostly-adequate-guide)

## Glossary of concepts

- Understand [isomorphic and
  universal](https://medium.com/@ghengeveld/isomorphism-vs-universal-javascript-4b47fb481beb)
  apps. Universal = run everywhere, isomorphic = server rendered for faster
  initial render on the client.

- [Memoization](https://codeburst.io/understanding-memoization-in-3-minutes-2e58daf33a19)

- [Strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)

- [Async](https://dev.to/kartik2406/async-operations-in-javascript-1k2c)

- [Named vs anonymous functions](https://www.linkedin.com/pulse/javascript-named-vs-anonymous-functions-chris-ng)

- [Currying](http://2ality.com/2011/09/currying-vs-part-eval.html) and partial
  application are two ways of transforming a function into another function with a
  generally smaller _arity_ (number of arguments). Currying always produces
  nested unary (1-ary) functions. The transformed function is still largely the
  same as the original. Partial application produces functions of arbitrary
  arity. The transformed function is different from the original – it needs less
  arguments. Interesting point of view in "[Currying is not idiomatic in
  JavaScript](http://2ality.com/2017/11/currying-in-js.html)". Currying is a
  technique for transforming functions so that they help with partial
  application.

- A [_falsy_](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) value is
  a value that is considered false when encountered in a Boolean context. Falsy
  values are `false`, `0`, `""`, `null`, `undefined` and `NaN`. Truthy values
  are all the rest. JavaScript coerces values to Boolean in Boolean contexts.

### Closures and scope

A [closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) is
the combination of a function and the lexical environment within which that
function was declared. This environment consists of any local variables that
were in-scope at the time the closure was created. [This Freecodecamp
article](https://medium.freecodecamp.org/javascript-closures-simplified-d0d23fa06ba4)
provides a good discussion. Try to understand this code:

```javascript
function outer() {
  var b = 10;
  var c = 100;
  function inner() {
    var a = 20;
    console.log('a=' + a + ' b=' + b);
    a++;
    b++;
  }
  return inner;
}

var X = outer(); // outer() invoked the first time
var Y = outer(); // outer() invoked the second time
//end of outer() function executions

X(); // X() invoked the first time
X(); // X() invoked the second time
X(); // X() invoked the third time

Y(); // Y() invoked the first time
```

The result is the following:

```bash
a=20 b=10
a=20 b=11
a=20 b=12
a=20 b=10
```

Notice that the updated value of `b` persists in `inner`'s closure from call to
call, as you can see from the consecutive calls to `X`. Note also that `c` will
not be part of `inner`'s closure. Finally, it's not that `a` is
overwritten/redeclared by `var a = 20`: it leaves memory every time `inner`
finishes and declared anew every new execution. It doesn't form part of the
closure.

<Todo>Read about scope and scope chain</Todo>

## JavaScript frameworks

- [Hyperapp](https://github.com/jorgebucaran/hyperapp/), 1kB JavaScript
  micro-framework for building declarative web applications.

## A review of ES6

This section has my notes from [ES6 For Everyone](https://es6.io/) with things
added whenever my curiosity pulled me into going a bit deeper. Another good
guide of [ES6 features](https://auth0.com/blog/a-rundown-of-es6-features/) provided by Auth0.

### A bit of history

[ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) is a scripting language
_specification_ of which JavaScript is the most popular _implementation_ (other
implementations are JScript, ActionScript and Google Apps Script).

The ES6 is ECMAScript version 6, published in June 2015. It seems that since
then, Ecma International has released a [new version every
June](https://en.wikipedia.org/wiki/ECMAScript#Versions), so in June 2018 we had
ES9.

If you've got time, Auth0 did a nice review of [JavaScript
history](https://auth0.com/blog/a-brief-history-of-javascript/):

- In the early days, Netscape, founded by Marc Andreessen, wanted to add dynamic
  features to the web. They came up with Mocha, which was to become a scripting
  language for the web. Simple, dynamic, and accessible to non-developers.

- They brought in Brendan Eich with the promise of developing "Scheme for the
  browser" (a dialect of [Lisp](http://landoflisp.com/)). Time pressure, the
  rising popularity of Java and Netscape's relationship with Sun Microsystems
  ended in "a premature lovechild of Scheme and Self, with Java looks".

- The Mocha prototype was integrated into Netscape in May 1995 and renamed
  LiveScript until December 1995 when it settled on JavaScript.

- JavaScript made such a considerable difference in user experience that
  competing browsers had no choice but to come up with a working solution, a
  working implementation of JavaScript.

- Microsoft called theirs JScript. The first version of JScript was included
  with Internet Explorer 3.0, released in August 1996.

- Brendan Eich rewrote Mocha to clean up the mess produced by the rushed
  release. The JavaScript engine in Netscape was named
  [SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey),
  and that has been carried over to Firefox to this day
  ([Mozilla](https://en.wikipedia.org/wiki/Mozilla) came out of Netscape).

- [Brendan Eich](https://brendaneich.com/2008/04/popularity/): "I’m happy that I
  chose Scheme-ish first-class functions and Self-ish (albeit singular)
  prototypes as the main ingredients. The Java influences, especially y2k Date
  bugs but also the primitive vs. object distinction (e.g., string vs. String),
  were unfortunate."

- Ecma International is an industry association formed in 1961 concerned solely
  with standardization of information and communications systems.

- Work on the standard for JavaScript was started in November 1996. The
  identification for the standard was ECMA-262 and the committee in charge was
  TC-39.

- The second version of the standard, ECMAScript 2, was released to fix
  inconsistencies between ECMA and the ISO standard for JavaScript (ISO/IEC
  16262), so no changes to the language were part of it. It was released in June 1998.

- AJAX, asynchronous JavaScript and XML, was a technique that was born in the
  years of ECMAScript 3. Although it was not part of the standard, Microsoft
  implemented certain extensions to JavaScript for its Internet Explorer 5
  browser. One of them was the `XMLHttpRequest` function (in the form of the
  XMLHTTP ActiveX control). This function allowed a browser to perform an
  asynchronous HTTP request against a server, thus allowing pages to be updated
  on-the-fly. Although the term AJAX was not coined until years later, this
  technique was pretty much in place.

- Work on ECMAScript 4 was fraught with strong differences within the committee.
  Some wanted to add big changes and features that would make JS more powerful,
  others thought that shouldn't be the path for JS. The work became so big and
  stretched out that ES4 was abandoned.

- If you are already familiar with ECMAScript 6/2015 you will notice that many
  features from ECMAScript 4 were reintroduced in it.

- All in all, ECMAScript 4 took almost 8 years of development and was finally
  scrapped. Adobe was in favor of many of the features that were included in ES4
  and they created ActionScript implementing those.

- In the year 2009 ECMAScript 3.1 was completed and signed-off by all involved
  parties. ECMAScript 4 was already recognized as a specific variant of
  ECMAScript even without any proper release, so the committee decided to rename
  ECMAScript 3.1 to ECMAScript 5 to avoid confusion.

- All-in-all, ECMAScript 5 was a modest improvement that helped JavaScript
  become a more usable language, for both small scripts, and bigger projects.
  Still, there were many good ideas from ECMAScript 4 that got scrapped and
  would see a return through the ECMAScript Harmony proposal.

- The ECMAScript Harmony proposal became a hub for future improvements to
  JavaScript. Many ideas from ECMAScript 4 were cancelled for good, but others
  were rehashed with a new mindset. ECMAScript 6, later renamed to ECMAScript
  2015, was slated to bring big changes.

- The release of ECMAScript 2015 caused a big jump in the use of transpilers
  such as Babel or Traceur. Even before the release, as these transpilers
  tracked the progress of the technical committee, people were already
  experiencing many of the benefits of ECMAScript 2015.

- A new release process implemented by TC-39. All new proposals must go through
  a four stage process. Every proposal that reaches stage 4 has a strong chance
  of getting included in the next version of ECMAScript (though the committee
  may still opt to push back its inclusion). This way proposals are developed
  almost on their own (though interaction with other proposals must be taken
  into account). Proposals do not stop the development of ECMAScript. If a
  proposal is ready for inclusion, and enough proposals have reached stage 4, a
  new ECMAScript version can be released.

### Variables (`var`, `let`, `const`)

- Scope: `var` is function scoped, `let` and `const` are block scoped, which is
  more restrictive.

- `var`s can be redeclared, even if it's not clear why you'd do that.

- Using `let` to redeclare a variable is not allowed in general, but inside a
  narrower scope it is.

- Using `const` on objects means the object shape cannot change, but the value
  of it's fields can. On arrays I'm not sure what it provides, probably that it
  has to remain an Array object. I can edit, add and remove elements from the
  `const` array. `Object.freeze()` can be used to make an object immutable.

- Before `let` and `const`, people used
  [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)'s to limit the
  scope of `var`s. Now, you can just use `let` or `const` inside a curly
  brackets `{ ... }`

- These pieces of code illustrate more advantages of `let` vs `var`. After 5
  seconds, this will print out 'Number is 10' ten times:

```javascript
for (var i = 0; i < 10; i += 1) {
  console.log(i);
  setTimeout(() => console.log(`Number is ${i}`), 5000);
}
```

Versus this, which will print out 'Number is 1', 'Number is 2', etc.

```javascript
for (let i = 0; i < 10; i += 1) {
  console.log(i);
  setTimeout(() => console.log(`Number is ${i}`), 5000);
}
```

- `let` and `const` also solve the temporal dead zone. I.e. they will throw an
  error if you reference them before declaring them. `var`s on the other hand,
  return undefined in that scenario.

- [Is `var` dead?](https://wesbos.com/is-var-dead/). My takeaway: use `const` by
  default, `let` when you need rebinding, don't use `var`.

### Functions

- Three main benefits from arrow functions: conciseness, implicit return, no
  rebinding of `this`.

- Implicit returns cannot be surrounded by curly braces. To return an object
  literal, which is surrounded by curly braces, you can wrap it in parenthesis.

- Arrow functions inside other functions don't rebind `this`, they inherit it
  from the parent. This makes them suited for certain cases, unsuited for
  others. For example:

```javascript
const box = document.querySelector('.box');
box.addEventListener('click', function() {
  // Regular function required for `this` to be `box`
  this.classList.toggle('opening');
  // Arrow function required for `this` to be `box`
  setTimeout(() => this.classList.toggle('opening'), 500);
});
```

- Be careful about using arrow functions whenever you want to use `this`. Some
  cases are inside functions, objects and prototype methods. They also don't
  provide access to the `arguments` object.

- You can do `function foo(a, b = 2, c = 3)` to pass default values for certain
  arguments. You can call this like `foo(1)`, `foo(1, 1)` and `foo(1, undefined, 1)`

### Template literals

- Template literals are string literals that accept embedded expressions and
  multi-line strings.

- [Tagged
  templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates)
  allow you to parse template literals with a function. The function signature
  for a tag would be `function myTag(strings, arg0, arg1)` or `function myTag(strings, ...args)` for an unknown number of arguments.

- Aside: you can use the
  [`debugger`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger)
  statement to invoke any
  available debugging functionality, such as setting a breakpoint. If no
  debugging functionality is available, this statement has no effect.

- Consider sanitizing tagged templates with [DOMPurify](https://github.com/cure53/DOMPurify).

### Mixed bag

- New string methods: `startsWith`, `endsWith`, `includes` and `repeat`. Avoids
  having to reach for regular expressions in some use cases. Wes showcases a nifty
  use of `repeat` for a left padding function that right aligns text:

```javascript
function leftPad(str, length = 20) {
  return `${' '.repeat(length - str.length)}${str}`;
}
```

- `padStart` and `padEnd` is even better for that.

### Destructuring

```javascript
// Assigning values to custom named variables
const { twitter: tw, facebook: fb } = wes.links.social;

// Using defaults
const settings = { width: 300, color: 'black' };
const { width = 100, height = 100, color = 'blue', fontSize = 25 } = settings;

// Destructuring arrays with rest
const team = ['Wes', 'Harry', 'Sarah', 'Keegan', 'Riker'];
const [captain, assistant, ...players] = team;

// Switching values
let inRing = 'Hulk Hogan';
let onSide = 'The Rock';
[inRing, onSide] = [onSide, inRing];

// Named arguments and default values for functions
function tipCalc({ total = 100, tip = 0.15, tax = 0.13 } = {}) {
  return total + tip * total + tax * total;
}
console.log(tipCalc());
console.log(tipCalc({ tip: 0.1, total: 80 }));
```

### `for` loops

- The `for` loops available in JavaScript are: regular `for`, `forEach` method
  available on Arrays and other objects, `for...in` and `for...of`. This last
  one seems to be the best - it provides readable syntax, `break` and `continue`
  support and works with everything except objects.

```javascript
for (const cut of cuts) {
  if (cut === 'Brisket') {
    continue;
  }
  console.log(cut);
}
```

- [Array.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)
  returns an Array iterator that can be used with the `for...of` loop.

- The recommended approach to iterate over objects is to use `for...in` or
  `for...of` with the `Object.entries()` method.

- Another strategy is to convert _arrayish_ things into arrays using
  `Array.from()` and `Array.of()`.

### Array methods

- `find` and `findIndex`

- The spread operator is useful for concatenating and cloning arrays:

```javascript
const pizzas = [...featured, 'veg', ...specialty];
const fridayPizzas = [...pizzas];
// fridayPizzas = pizzas creates a new reference to the same
// array in memory, not a new array
```

### Object literal upgrades

You don't need to specify `property: variable` when `variable` has the same name
as `property`. Same goes for functions. Also, object keys can now be generated
dynamically using template strings.

```javascript
const first = 'snickers';
const last = `bos`;
const age = 2;
const breed = 'King Charles Cav';
const dog = {
  firstName: first,
  last,
  age,
  breed,
  pals: ['Hugo', 'Sunny']
};

const modal = {
  create(selector) {
    /* body */
  },
  open(content) {
    /* body */
  },
  close(goodbye) {
    /* body */
  }
};

const invertColor = color => `#cccccc`;

const key = 'pocketColor';
const value = '#ffc600';
const tShirt = {
  [key]: value,
  [`${key}Opposite`]: invertColor(value)
};
```

### Promises and async/await

### Generators

### Proxies

### Sets

### Maps
