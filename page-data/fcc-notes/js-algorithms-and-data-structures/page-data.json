{"componentChunkName":"component---src-components-layout-jsx","path":"/fcc-notes/js-algorithms-and-data-structures","webpackCompilationHash":"65627bb980c34939f462","result":{"data":{"mdx":{"id":"f6705dd0-fa2c-5afd-8582-799483a426d3","fields":{"title":"freeCodeCamp's JS Algorithms and Data Structures","slug":"/fcc-notes/js-algorithms-and-data-structures"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"freeCodeCamp's JS Algorithms and Data Structures\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"JS Algorithms And Data Structures Certification\"), mdx(\"p\", null, \"Notes from following freeCodeCamp's JS algorithms and data structures cert.\"), mdx(\"h2\", null, \"Basic JavaScript\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check out the assortment of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Overview\"\n  }), \"assignment\\noperators\"), \".\\nI typically only use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"+=\"), \" and never think of using the rest!\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Characters in string are immutable. The strings themselves are not. So you can\\nchange the value of a whole string (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s = 'new value'\"), \"), you can read single\\ncharacters with bracket notation (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let t = s[2]\"), \"), but you cannot change a single\\ncharacter in an existing string (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s[2] = 'a' // not!\"), \").\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Become more fluent with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javascript.info/array-methods#summary\"\n  }), \"array\\nmethods\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"push\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pop\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shift\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unshift\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"splice\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"slice\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"concat\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"indexOf\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lastIndexOf\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"includes\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"find\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findIndex\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"split\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"join\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduceRight\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isArray\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Assigning a value to an undeclared variable \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#Description\"\n  }), \"implicitly creates\\nit\"), \"\\nas a global variable (it becomes a property of the global object) when the\\nassignment is executed. The differences between declared and undeclared\\nvariables are:\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Declared variables are constrained in the execution context in which they\\nare declared. Undeclared variables are always global.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Declared variables are created before any code is executed. Undeclared\\nvariables do not exist until the code assigning to them is executed.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Declared variables are a non-configurable property of their execution context\\n(function or global). Undeclared variables are configurable (e.g. can be\\ndeleted).\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Study scopes.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Understand coercion and different behavior between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"==\"), \" vs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"===\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!=\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!==\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Review \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javascript.info/switch\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"switch\"), \" syntax and patterns\"), \".\"))), mdx(\"h2\", null, \"ES6\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It seems that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'use strict';\"), \" at the top of your files or the start of\\nfunctions is recommended. It's rather annoying to have to write that every time,\\ndon't you think? Javascript.info has a good succinct \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javascript.info/strict-mode\"\n  }), \"article on how to use\\nstrict mode\"), \".\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"I've also found some recommendations warning that if your code is processed by\\nsome build system (minification, concatenation...), you might have unexpected\\nresults when mixing strict and sloppy scripts. One solution is to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'use strict';\"), \" at the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.geeksforgeeks.org/strict-mode-javascript/\"\n  }), \"start of\\nfunctions\"), \". Another\\nproblem to consider is that if your code is executed in older browsers, they\\nmight not support strict mode and you might get unexpected results as well.\\nPreventing problems in this scenario would require careful testing.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In JavaScript, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mariusschulz.com/blog/constant-variables-in-javascript-or-when-const-isnt-constant\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"const\"), \" does not mean\\nconstant\"), \",\\nbut one-time assignment. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"But\"), \", the part that's constant is the reference to\\nan object stored within the constant variable, not the object itself.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const settings = {\\n  baseUrl: 'https://example.com'\\n};\\n\\nsettings = {}; // fail!\\nsettings.baseUrl = 'https://evil.example.com'; // win!\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Declaring a variable to be constant doesn't make the objects it references\\nimmutable. Object properties can change or be deleted altogether. The same\\ngoes for arrays assigned to a constant variable; Elements can be added,\\nremoved, reordered, or modified.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To make an object truly immutable, you can pass it to the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Object.freeze\")), \"\\nfunction to prevent any changes to its properties. Be aware that freeze is\\nshallow, so you'll have to recursively call it for nested objects if you want\\nthe entire object tree to be frozen. If you need immutable data structures, it\\nmight be safer and more convenient to use a library such as Facebook's\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/immutable-js/\"\n  }), \"Immutable.js\"), \" which is specifically\\nmade for this purpose.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\"\n  }), \"arrow function\\nexpression\"), \"\\nis a syntactically compact alternative to a regular function expression,\\nalthough without its own bindings to the this, arguments, super, or new.target\\nkeywords.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Arrow function expressions are ill suited as methods, and they cannot be used\\nas constructors. Arrow functions are always anonymous. Two factors influenced\\nthe introduction of arrow functions: shorter functions and non-binding of\\nthis. An arrow function does not have its own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \"; the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" value of the\\nenclosing execution context is used.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions that operate on other functions, either by taking them as arguments\\nor by returning them, are called higher-order functions. Eloquent JavaScript has\\na great article on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://eloquentjavascript.net/05_higher_order.html\"\n  }), \"higher-order\\nfunctions\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"I always forget that I can declare function parameters with default values.\\nDefault function parameters allow named parameters to be initialized with\\ndefault values if no value or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" is passed:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function multiply(a, b = 1) {\\n  return a * b;\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"I use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"\n  }), \"destructuring\\nassignment\"), \"\\nregularly, but I rarely reach out for new names and default values:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let o = { p: 42, q: true };\\nlet { p, q } = o; // basic\\nlet { p: foo, q: bar } = o; // new names\\nlet { q = false, r = 'hi' } = o; // default values\\nlet { p: foo = 1, q, r: bar = 'hi' } = o; // combined\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"I haven't written much code using classes in JavaScript. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\"\n  }), \"JavaScript\\nclasses\"), \",\\nintroduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript's\\nexisting prototype-based inheritance. The class syntax does not introduce a new\\nobject-oriented inheritance model to JavaScript. JavaScript.info \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javascript.info/class\"\n  }), \"article on\\nclasses\"), \" is quite good.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In summary, the basic class syntax looks like this:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"class MyClass {\\n  prop = value;\\n\\n  constructor(...) {\\n    // ...\\n  }\\n\\n  method(...) {}\\n\\n  get something(...) {}\\n  set something(...) {}\\n\\n  [Symbol.iterator]() {}\\n  // ...\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyClass\"), \" is technically a function. Methods are written to\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyClass.prototype\"), \".\"))), mdx(\"h2\", null, \"Regular Expressions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Use regular expressions with many methods. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javascript.info/regexp-methods#recipes\"\n  }), \"Popular\\nones\"), \" are:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"str.match(regExp)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"regExp.test(str)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"str.replace(regExp, newStr|fun)\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Match literals like this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/hello/\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Provide alternatives like this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/yes|no|maybe/\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Flags go at the end of the regular expression like this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/regex/flags\"), \".\\nThe two most popular flags are: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" for case insensitive search and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \" for\\nglobal search.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".\"), \" matches any character except newline, but can be made to include newline\\nwith the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s\"), \" flag.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Use square brackets to define character sets: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/[abc]/\"), \" would be equivalent to\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/a|b|c/\"), \", if I'm not mistaken. Use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-\"), \" to define ranges. Use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[^...]\"), \" to\\ndefine a character set by specifying its complement. I.e. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[^abc]\"), \" matches\\neverything \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"except\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"For frequently used character sets, shorthand \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"character classes\"), \" exist. The\\nmost popular:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\w\"), \" equivalent to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[A-Za-z0-9_]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\W\"), \" its complement\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\d\"), \" equivalent to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[0-9]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\D\"), \" its complement\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\s\"), \" equivalent to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[ \\\\r\\\\t\\\\f\\\\n\\\\v]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\S\"), \" its complement.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Quantifiers establish whether a given character or group can repeat itself:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"?\"), \" 0 or 1 times\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"*\"), \" 0 or more times\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"+\"), \" 1 or more times\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{n}\"), \" exactly n times\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{min,max}\"), \" a number of times in between min and max (inclusive). Either min\\nor max can be omitted.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"^\"), \" at the beginning of the regular expression denotes beginning of string.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$\"), \" at the end denotes end of string.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Lookaheads establish an extra condition without becoming part of the match.\\nPositive lookahead \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x(?=y)\"), \" matches \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" when followed by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \". Negative lookahead\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x(?!y)\"), \" matches \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" when \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" followed by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"^\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \" mean different things depending on where they're used.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"By default, regular expressions behave in a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"greedy\"), \" manner. For example,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/t[a-z]*i/\"), \" applied to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"titanic\\\"\"), \" will produce the biggest match,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"titani\\\"\"), \". By adding a question mark like so \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/t[a-z]*?i/\"), \", the match behaves\\nin a lazy manner and the smallest match is returned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"ti\\\"\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Create capture groups by using parenthesis \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(...)\"), \", which can be referenced\\nsubsequently inside the regular expression by number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\2\"), \", etc. They can\\nalso be referenced in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"replace\"), \" like so \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$2\"), \", etc.\"))), mdx(\"h2\", null, \"Debugging\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Three types of bugs:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"syntax errors that prevent a program from running,\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"runtime errors when code fails to execute or has unexpected behavior, and\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"semantic (or logical) errors when code doesn't do what it's meant to.\")))), mdx(\"h2\", null, \"Object Oriented Programming\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An object is just a data structure that holds property/value pairs. The values\\ncan be of any arbitrary type: strings, numbers, objects... When a property has a\\nvalue of type Function, we call it a method.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Constructors are functions that create new objects. They follow a few\\nconventions:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"They are defined with a capitalized name to distinguish them from other\\nfunctions that are not constructors.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"They use the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" to set properties of the object they will\\ncreate. Inside the constructor, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" refers to the new object it will\\ncreate.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"They define properties and behaviors instead of returning a value as other\\nfunctions might.\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"You can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"obj instanceof Obj\"), \" to test if a specific \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"obj\"), \" object is an\\ninstance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Obj\"), \" constructor.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An object has two types of properties: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"own\"), \" properties and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"prototype\"), \"\\nproperties. Own properties are defined directly on the object instance itself.\\nAnd prototype properties are defined on the prototype. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".hasOwnProperties(key)\"), \"\\nreturns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" for prototype properties, but the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" operator works with\\nboth. But it's more complicated, so check \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\"\n  }), \"Enumerability and ownership of\\nproperties\")), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Enumerable properties are those properties whose internal enumerable flag is\\nset to true, which is the default for properties created via simple assignment\\nor via a property initializer (properties defined via Object.defineProperty\\nand such default enumerable to false). Enumerable properties show up in\\nfor...in loops unless the property's key is a Symbol. Ownership of properties\\nis determined by whether the property belongs to the object directly and not\\nto its prototype chain. Properties of an object can also be retrieved in\\ntotal.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Manually setting the prototype of a new object will erase (overwrite, I guess)\\nthe constructor property. One solution is to include the constructor in the\\nobject literal we're using to overwrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prototype\"), \".\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function Dog(name) {\\n  this.name = name;\\n}\\n\\n// Modify the code below this line\\nDog.prototype = {\\n  constructor: Dog,\\n  numLegs: 2,\\n  eat: function() {\\n    console.log('nom nom nom');\\n  },\\n  describe: function() {\\n    console.log('My name is ' + this.name);\\n  }\\n};\\n\")))), mdx(\"h2\", null, \"Functional programming\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functional programming is about:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Isolated functions - there is no dependence on the state of the program,\\nwhich includes global variables that are subject to change\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Pure functions - the same input always gives the same output\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions with limited side effects - any changes, or mutations, to the\\nstate of the program outside the function are carefully controlled\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions passed as arguments are referred to as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"callbacks\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions that can be assigned to a variable, passed into another function, or\\nreturned from another function just like any other normal value, are called\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"first class\"), \" functions. All functions are first class in JavaScript.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions that take functions as arguments or return functions are called\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"higher order\"), \" functions. The functions that are passed as arguments or\\nreturned as results are called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lambdas\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In functional programming, changing or altering things is called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutation\"), \",\\nand the outcome is called a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"side effect\"), \". A function, ideally, should be a\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pure function\"), \", meaning that it does not cause any side effects.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Another principle of functional programming is to always declare your\\ndependencies explicitly. This means if a function depends on a variable or\\nobject being present, then pass that variable or object directly into the\\nfunction as an argument.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" caveat: the first time the callback is called, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accumulator\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentValue\"), \" can be one of two values. If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValue\"), \" is provided in the call\\nto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce()\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accumulator\"), \" will be equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValue\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentValue\"), \"\\nwill be equal to the first value in the array. If no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValue\"), \" is provided,\\nthen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accumulator\"), \" will be equal to the first value in the array, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentValue\"), \"\\nwill be equal to the second.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check out the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"every\")), \"\\nand\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"some\")), \"\\nmethods!\"))));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"JS Algorithms And Data Structures Certification","depth":1},{"value":"Basic JavaScript","depth":2},{"value":"ES6","depth":2},{"value":"Regular Expressions","depth":2},{"value":"Debugging","depth":2},{"value":"Object Oriented Programming","depth":2},{"value":"Functional programming","depth":2}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"f6705dd0-fa2c-5afd-8582-799483a426d3"}}}