{"componentChunkName":"component---src-components-layout-jsx","path":"/programming/nodejs","result":{"data":{"mdx":{"id":"e24f6427-8455-5f95-bf63-b9de0a976a10","fields":{"title":"Node.js","slug":"/programming/nodejs"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Node.js\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Node.js\"), mdx(\"h2\", null, \"Courses\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://learnnode.com/\"\n  }), \"Learn Node\"), \" by Wes Bos.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.edx.org/course/building-functional-prototypes-using-nodejs-5\"\n  }), \"Building functional prototypes with\\nNode.js\"), \"\\nby Microsoft on edX (free)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://codewithmosh.com/p/the-complete-node-js-course\"\n  }), \"The complete Node.js\\ncourse\"), \" by Mosh\\nHamedani.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.udemy.com/course/the-complete-nodejs-developer-course-2/\"\n  }), \"The Complete Node.js Developer\\nCourse\"), \" by\\nAndrew Mead.\")), mdx(\"h2\", null, \"Topics to master\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understanding Node.js, what it is, where it comes from, what it's used for\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understanding npm and how to use it\")), mdx(\"h2\", null, \"Environment variables\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/the-node-js-collection/making-your-node-js-work-everywhere-with-environment-variables-2da8cdf6e786\"\n  }), \"This\\narticle\"), \"\\nmakes a case for environment variables.\"), mdx(\"h3\", null, \"Why?\"), mdx(\"p\", null, \"Because they externalize all environment specific aspects of your app and\\nkeep your app encapsulated. Now you can run your app anywhere by modifying the\\nenvironment variables \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"without changing your code and without rebuilding it\"), \"!\"), mdx(\"h3\", null, \"When?\"), mdx(\"p\", null, \"Some examples:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Which HTTP port to listen on\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What path and folder your files are located in, that you want to serve\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pointing to a development, staging, test, or production database\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"URLs to server resources\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CDNs for testing vs. production\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Even a marker to label your app in the UI by the environment it lives in\")), mdx(\"h3\", null, \"How?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using the local environment (duh) and/or command line. We're talking about\\n\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"environment\"), \" variables, after all. They could be present in memory as part of\\nthe execution context or you can pass them through the command line. Assuming\\nyou use bash:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"PORT=8626 node server.js\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using .env file. Keeps things tidy and convenient and avoids typing mistakes.\\nI also think the previous solution has a higher risk of leaking data to the\\nenvironment. When you add a variable to bash, other processes might be able to\\naccess that value. When you use dotenv, I think the variables are attached to\\nyour application process and can only be seen by it.\")), mdx(\"p\", null, \"In any case, just use dotenv. Add your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".gitignore\"), \" and you\\nalso have a convenient way of keeping your secrets accessible and (somewhat)\\nprotected.\"), mdx(\"p\", null, \"Read the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/dotenv\"\n  }), \"dotenv docs\"), \" for details on how\\nto use it. I've seen two different ways of accessing values:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Using the dot notation: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"process.env.PORT\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Using the bracket notation: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"process.env['PORT']\"))), mdx(\"p\", null, \"I'm assuming they're equivalent and who cares, but I like bracket notation\\nbetter. It would make it easier to use them programmatically like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const keys = ['PORT', 'ENDPOINT', 'SECRET'];\\nfor (key of keys) {\\n  let value = process.env[key];\\n  // do something with value\\n}\\n\")), mdx(\"p\", null, \"For consistency, why not use that notation everywhere.\"), mdx(\"p\", null, \"Also follow the recommendation of a single .env file per environment. From \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://12factor.net/config\"\n  }), \"The\\nTwelve-Factor App\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"In a twelve-factor app, env vars are granular controls, each fully orthogonal\\nto other env vars. They are never grouped together as \\u201Cenvironments\\u201D, but\\ninstead are independently managed for each deploy. This is a model that scales\\nup smoothly as the app naturally expands into more deploys over its lifetime.\")));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"Node.js","depth":1},{"value":"Courses","depth":2},{"value":"Topics to master","depth":2},{"value":"Environment variables","depth":2},{"value":"Why?","depth":3},{"value":"When?","depth":3},{"value":"How?","depth":3}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"e24f6427-8455-5f95-bf63-b9de0a976a10"}}}